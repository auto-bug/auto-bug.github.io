---
blogpost: true
date: 2015-06-17
category: project-6050
---

# Remote control with ESP8266 and Micropython
Published on 2015-06-17 in {ref}`project-6050`.

Since some time I was planning to write a log about how to extend Tote
with additional boards. I was planning to show examples of connecting
the Raspberry Pi, Teensy 3.1, ESP8266 and anything else I could find,
all running different kinds of Python. That would also let me score
more points in the " [mountain of prizes](http://hackaday.com/2015/06/08/a-mountain-of-prizes-for-projects-using-these-parts/) " as those boards use chips from all kinds of manufacturers, and I
could claim then that Tote "uses" them. But reality as always
interferes.
---


Raspberry Pi now requires at least 3GB SD card for its system image,
and turns out I don't have any that big around.

The Micropython port for Teensy 3.1 doesn't yet support UART (even
though the module with all the functions is there, they just do
nothing).

The Micropython port for ESP8266 doesn't have enough room for my
Python code for controlling the robot.

So I had to settle down to just showing how to do remote control over
something else than a TV remote. I'm still using the ESP8266 with
Micropython on it, except instead of controlling the motions of the
whole robot with it, as I planned, I'm just passing the keypresses
from the computer, and the Arduino still takes care of moving the
legs. Oh well. It still took me several hours of debugging to get
working.

Let's start with a very simple thing -- controlling the robot over a
serial cable, connected directly to an USB2TTL module stuck in your
computer's USB port. You need three wires: GND, TX and RX. You connect
them to the FTDI header on the Pro Mini, and to the USB2TTL in
following way:


 * GND ↔ GND
 * RX ↔ TX
 * TX ↔ RX

By the way, this is also an excellent way of debugging the robot --
you can print stuff to the serial console and verify that the program
does what you think it should. Anyways, you will need some extra code
on your Pro Mini too. There are two ways to go about this.

You can just have a very simple [servo controller](https://bitbucket.org/thesheep/ukubik/src/tip/ukubik/)  on the Arduino side, and feed it servo positions every frame from the [Python code for the gaits](https://bitbucket.org/thesheep/ukubik/src/tip/creep.py) . That's exactly what the {ref}`project-3300` 

 [](https://bitbucket.org/thesheep/tote/src/tip/start/)  [](https://bitbucket.org/thesheep/tote/src/460f15fa2da489125bb3ade9d76b81fb3b1b60ad/start/serial.ino?at=serial-control) 


<iframe style="width: 500px; height: 281px;" width="500" height="281" frameborder="0" allowfullscreen="None" src="https://www.youtube.com/embed/Da69xJNugLQ"></iframe>




:::{image} https://cdn.hackaday.io/images/9500271434528311364.jpg

:::


 [](https://learn.adafruit.com/building-and-running-micropython-on-the-esp8266)  [](https://github.com/micropython/micropython/tree/master/docs/library) 


```python

```

______


```python

```

__
```ruby

```




:::{image} https://cdn.hackaday.io/images/6642121434528945481.jpg

:::


__


:::{image} https://cdn.hackaday.io/images/2532981434529049651.jpg

:::




________




<iframe style="width: 500px; height: 281px;" width="500" height="281" frameborder="0" allowfullscreen="None" src="https://www.youtube.com/embed/4HnUbrXEJcQ"></iframe>



