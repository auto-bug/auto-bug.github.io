<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <id>http://deshipu.art/</id>
  <title>deshipu.art</title>
  <updated>2024-08-07T20:33:02.068245+00:00</updated>
  <link href="http://deshipu.art/"/>
  <link href="http://deshipu.art/blog/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.33">ABlog</generator>
  <entry>
    <id>http://deshipu.art/projects/project-80626/log-209169/</id>
    <title>PNG Support</title>
    <updated>2022-07-27T00:00:00+02:00</updated>
    <content type="html">&lt;section id="png-support"&gt;

&lt;p&gt;Published on 2022-07-27 in &lt;a class="reference internal" href="../projects/project-80626/#project-80626"&gt;&lt;span class="std std-ref"&gt;Stage, a Tile and Sprite Engine&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;img alt="projects/project-80626/images/192731658873601053.jpg" src="projects/project-80626/images/192731658873601053.jpg" /&gt;
&lt;p&gt;When I just started with the Stage library, I used BMP files for the
graphics, mostly because they were uncompressed, so it seemed the
easiest way. And it was good enough for a prototype, to confirm this
is possible. But there are a lot of problems with BMP files, starting
with their size, end ending with the fact that there isn’t really any
official spec of them, and they have a lot of incompatible variants
and versions. So while my code worked fine with images saved with
GIMP, it didn’t with those created with other programs. And honestly,
forcing people to use GIMP is just too cruel.&lt;/p&gt;
&lt;p&gt;So for easier use, I decided to add GIF support. I took some work, as
the compression algorithm is pretty tricky, but I got it done in pure
Python, and with some restrictions, included it in the Stage library.
GIF files are pretty much the same no matter what saves them, so that
makes things a little bit easier for everyone. Or so I thought.&lt;/p&gt;
&lt;p&gt;Unfortunately, when I looked at how people try to use this library at
the recent EuroPython conference, I had to revise my conclusions. You
see, for most people GIF is animated format. That means that most
sprite-making software, when asked to save as GIF, will create an
animation of your sprite’s frames, instead of an atlas. And that is
very much not what Stage expects. The fact that you need to have at
most 16 colors is also a problem, as many programs will happily add
colors to your palette while handling or converting your GIFs,
resulting in files that used to work stopping working when you edit
them.&lt;/p&gt;
&lt;p&gt;So what format should I be using? PNG is the most popular format for
static pixel-art in the community, and most tools support exporting
atlases of frames to that format. It’s also pretty well specified, so
all the tools generate the same format. But the compression algorithm
for PNG is even more complicated than for GIF, so what can I do? Turns
out that the compression algorithm used by PNG, zlib deflate, is
actually built-in into Python! And CircuitPython has an efficient C
implementation of it available as a module too! So I don’t have to
worry about the compression at all, I just need to handle the file
structure, which is even simpler than in GIF.&lt;/p&gt;
&lt;p&gt;So today I sat down, read the PNG specification, and wrote the ~50
lines of code needed to load the images. And it works! I even managed
to fit the extra code and the zlib module on the PewPew M4 boards (I
just had to nudge a bit the Japanese translation). Once the pull
request merges, we will be able to use PNG images, and I will try to
write a detailed tutorial.&lt;/p&gt;
&lt;p&gt;Update: I had to remove the GIF support after all, to make room.&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="http://deshipu.art/projects/project-80626/log-209169/" rel="alternate"/>
    <summary>Published on 2022-07-27 in project-80626.</summary>
    <published>2022-07-27T00:00:00+02:00</published>
  </entry>
  <entry>
    <id>http://deshipu.art/projects/project-158701/log-213092/</id>
    <title>Where Are We?</title>
    <updated>2022-11-01T00:00:00+01:00</updated>
    <content type="html">&lt;section id="where-are-we"&gt;

&lt;p&gt;Published on 2022-11-01 in &lt;a class="reference internal" href="../projects/project-158701/#project-158701"&gt;&lt;span class="std std-ref"&gt;Video Pendant&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Hardware-wise, I think I’m reasonably happy with what I have – at
least it’s more than sufficient as a prototype for testing. What I
need now is the software. I have tested the device with CircuitPython
– I have even written a GIF decoding library in pure Python specially
for this – and I’m confident this can work, but not with
CircuitPython. So the next step is to get the the firmware for this
working.&lt;/p&gt;
&lt;p&gt;I can use the TinyUSB library to expose the filesystem over USB – it’s
the same library that CircuitPython is using, in fact. And I can use a
super-optimized GIF library written by &lt;a class="reference external" href="https://hackaday.io/hacker/269676"&gt;&amp;#64;Larry Bank&lt;/a&gt; . That should get me the minimal functionality. I can then also
experiment with sleep modes and touch and all that stuff.&lt;/p&gt;
&lt;p&gt;The problem I am facing right now is setting up an environment for
development for the SAMD21. I will probably start with Arduino,
because that is already mostly ready out of the box, but there is
still some work with that, that I currently just can’t get myself
started on. So until I get that going, the project is on hold.&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="http://deshipu.art/projects/project-158701/log-213092/" rel="alternate"/>
    <summary>Published on 2022-11-01 in project-158701.</summary>
    <published>2022-11-01T00:00:00+01:00</published>
  </entry>
  <entry>
    <id>http://deshipu.art/projects/project-10408/log-213614/</id>
    <title>Kos v2.0</title>
    <updated>2022-11-21T00:00:00+01:00</updated>
    <content type="html">&lt;section id="kos-v2-0"&gt;

&lt;p&gt;Published on 2022-11-21 in &lt;a class="reference internal" href="../projects/project-10408/#project-10408"&gt;&lt;span class="std std-ref"&gt;Steno Keyboard&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In Kos 1.0 I used a pro mini board for the microcontroller, because
that was the traditional way at the time, and it had the most
widespread support. But it’s an old microcontroller and the board is
hard to get and expensive during the chip shortage, when the chip fabs
are busy churning out chips for the missiles, so I decided to revisit
this design and this time use something modern – the Raspberry Pi
Pico, which is both cheap and available, at least until the military
designs catch up with the new chip technology.&lt;/p&gt;
&lt;p&gt;With more pins available on each side, and with the board being mostly
symmetrical, I could simplify the design greatly. I no longer need to
connect the rows across the two halves, and I can simply have all
horizontal traces on one side, and all vertical traces on the other.&lt;/p&gt;
&lt;img alt="projects/project-10408/images/7478231669027498191.png" src="projects/project-10408/images/7478231669027498191.png" /&gt;
&lt;img alt="projects/project-10408/images/4817741669027510528.png" src="projects/project-10408/images/4817741669027510528.png" /&gt;
&lt;p&gt;As with the previous versions, you need two of the PCBs to make one
keyboard, and you connect them by soldering a pro micro in the middle.
Since QMK now supports RP2040, there shouldn’t be any problem with the
firmware, but I will probably use the CircuitPython code I already
wrote for the other stenotype, or maybe try and get the USB HID steno
protocol working. The Pi Pico opens a lot of possibilities, even
putting a simplified version of Plover together with the dictionary on
the board itself, and emulating a HID keyboard should be doable.&lt;/p&gt;
&lt;p&gt;As usual, the PCBs and parts should arrive within two weeks.&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="http://deshipu.art/projects/project-10408/log-213614/" rel="alternate"/>
    <summary>Published on 2022-11-21 in project-10408.</summary>
    <published>2022-11-21T00:00:00+01:00</published>
  </entry>
  <entry>
    <id>http://deshipu.art/projects/project-9927/log-216775/</id>
    <title>This is not the robot you are looking for</title>
    <updated>2023-03-16T00:00:00+01:00</updated>
    <content type="html">&lt;section id="this-is-not-the-robot-you-are-looking-for"&gt;

&lt;p&gt;Published on 2023-03-16 in &lt;a class="reference internal" href="../projects/project-9927/#project-9927"&gt;&lt;span class="std std-ref"&gt;Tote HaD&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Apparently there are some rumors that this is a robot we are going to
be building at a workshop in Berlin during the 2023 Hackaday
conference. That is not true.&lt;/p&gt;
&lt;p&gt;This is the robot we were building back in 2016 in Belgrade.&lt;/p&gt;
&lt;p&gt;Yes, there is going to be a robot-building robot in Berlin, but we are
going to be building &lt;span class="xref std std-ref"&gt;project-180025&lt;/span&gt; , which is a newer design with many improvements.&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="http://deshipu.art/projects/project-9927/log-216775/" rel="alternate"/>
    <summary>Published on 2023-03-16 in project-9927.</summary>
    <published>2023-03-16T00:00:00+01:00</published>
  </entry>
  <entry>
    <id>http://deshipu.art/projects/project-158701/log-223060/</id>
    <title>Goodbye</title>
    <updated>2023-09-11T00:00:00+02:00</updated>
    <content type="html">&lt;section id="goodbye"&gt;

&lt;p&gt;Published on 2023-09-11 in &lt;a class="reference internal" href="../projects/project-158701/#project-158701"&gt;&lt;span class="std std-ref"&gt;Video Pendant&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I decided to stop pretending I will ever finish this project, and put
it out of its misery.&lt;/p&gt;
&lt;p&gt;I still believe it’s generally possible to get the exact hardware I
used to display animated GIF that you can easily upload to an USB
drive. However, it would require a bit of work to write the firmware
that does it, and I find that I no longer am interested in doing that
work.&lt;/p&gt;
&lt;p&gt;While I was procrastinating, CircuitPython grew a gifio library, that
displays animated GIFs straight from the filesystem. It’s as simple to
use as:&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;board&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;gifio&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;displayio&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;struct&lt;/span&gt;


&lt;span class="n"&gt;display&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;board&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DISPLAY&lt;/span&gt;
&lt;span class="n"&gt;odg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gifio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnDiskGif&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sample.gif&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;monotonic&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;next_delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;odg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_frame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# Load the first frame&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;monotonic&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;overhead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;auto_refresh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;False&lt;/span&gt;
&lt;span class="n"&gt;display_bus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;next_delay&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;overhead&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;next_delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;odg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next_frame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;display_bus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;hh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;odg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;display_bus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;struct&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;gt;hh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;odg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;display_bus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;odg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;That’s it. It works. But of course not on the SAMD21, which has way
too little flash and memory to fit it all. I have built a custom
version of CircuitPython that has almost everything disabled to fit
gifio, and it kinda works, except of course:&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Auto&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;reload&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Simply&lt;/span&gt; &lt;span class="n"&gt;save&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="n"&gt;over&lt;/span&gt; &lt;span class="n"&gt;USB&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;them&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;enter&lt;/span&gt; &lt;span class="n"&gt;REPL&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;disable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;code.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; 
&lt;span class="ne"&gt;MemoryError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;memory&lt;/span&gt; &lt;span class="n"&gt;allocation&lt;/span&gt; &lt;span class="n"&gt;failed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;allocating&lt;/span&gt; &lt;span class="mi"&gt;24024&lt;/span&gt; &lt;span class="nb"&gt;bytes&lt;/span&gt;

&lt;span class="n"&gt;Code&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;running&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;Press&lt;/span&gt; &lt;span class="nb"&gt;any&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;enter&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;REPL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Use&lt;/span&gt; &lt;span class="n"&gt;CTRL&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;reload&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I’m sure I could tweak the gifio library to make it use smaller
buffers and make it fit in that RAM. But I don’t want to.&lt;/p&gt;
&lt;p&gt;I also don’t want to write the whole thing in C, using tinyUSB and a
gif library. It just feels too much like work, and very little like
fun exploration.&lt;/p&gt;
&lt;p&gt;Note that I will probably get back to the idea of a pendant with a
display showing animated GIFs. Especially since it’s now literally
just a few lines of code in CircuitPython. But I will probably use a
different displays and definitely a more powerful microcontroller. And
I will possibly just use a ready development board, such as the
Seeedstudio Xiao, because there is very little I would gain doing a
bare chip thing from scratch at this point (and because I got spoiled
by SAMD21’s minimal component count, and any other microcontroller
feels like too much work now). \&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="http://deshipu.art/projects/project-158701/log-223060/" rel="alternate"/>
    <summary>Published on 2023-09-11 in project-158701.</summary>
    <published>2023-09-11T00:00:00+02:00</published>
  </entry>
</feed>
